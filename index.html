<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>DAFT Package Challenge</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="index_files/libs/clipboard/clipboard.min.js"></script>
<script src="index_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="index_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="index_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="index_files/libs/quarto-html/popper.min.js"></script>
<script src="index_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="index_files/libs/quarto-html/anchor.min.js"></script>
<link href="index_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="index_files/libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="index_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="index_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="index_files/libs/bootstrap/bootstrap-9e3ffae467580fdb927a41352e75a2e0.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">DAFT Package Challenge</h1>
<p class="subtitle lead">Recreating the Scurvy DAGs with Beautiful Visualizations</p>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="daft-package-challenge---recreating-the-scurvy-dags" class="level1">
<h1>üé® DAFT Package Challenge - Recreating the Scurvy DAGs</h1>
<!--
::: {.callout-important}
## üìä Challenge Requirements In Section [Student Analysis Section](#student-analysis-section)
- Recreate all three scurvy DAGs using DAFT programming
- Optional: Demonstrate understanding of DAFT customization options
:::

## The Problem: Mastering Probabilistic Graphical Models with DAFT

**Core Question:** How can we use the DAFT package to create visually appealing Directed Acyclic Graphs (DAGs) that tell a compelling data story?

**The Challenge:** You'll recreate three historical DAGs depicting the fascinating story of how we lost and rediscovered the cure to scurvy. This challenge teaches you to use DAFT for creating professional-quality probabilistic graphical models.

**Our Approach:** We'll work through the three different understandings of the scurvy data generating process, learning DAFT customization techniques while exploring a crucial moment in medical history.

::: {.callout-warning}
## ‚ö†Ô∏è AI Partnership Required

This challenge pushes boundaries intentionally. You'll tackle problems that normally require weeks of study, but with Cursor AI as your partner (and your brain keeping it honest), you can accomplish more than you thought possible.

**The new reality:** The four stages of competence are Ignorance ‚Üí Awareness ‚Üí Learning ‚Üí Mastery. AI lets us produce Mastery-level work while operating primarily in the Awareness stage. I focus on awareness training, you leverage AI for execution, and together we create outputs that used to require years of dedicated study.
:::

## The Scurvy Story: A Data Science Tragedy

Scurvy was a devastating disease that affected sailors on long voyages. The cure was discovered in 1747, but due to a misunderstanding about the cause, the cure was lost for over 150 years. The story involves three different understandings of the data generating process:

1. **1747 Understanding:** Lemons prevent scurvy (correct but incomplete!)
2. **Misguided Belief:** Acid kills bacteria that causes scurvy (wrong!)
3. **1928 Understanding:** Vitamin C prevents scurvy (the real mechanism)

## Environment Setup

First, let's install the DAFT package and set up our environment:

::: {#setup-environment .cell message='false' execution_count=1}
``` {.python .cell-code}
# Install DAFT package (run this in terminal if not already installed)
# pip install 'daft-pgm'

import daft
import matplotlib.pyplot as plt
import numpy as np

# Set up plotting parameters for better quality
plt.rcParams['figure.dpi'] = 150
plt.rcParams['savefig.dpi'] = 300

print("DAFT package imported successfully!")
print("Ready to create beautiful DAGs!")
```

::: {.cell-output .cell-output-stdout}
```
DAFT package imported successfully!
Ready to create beautiful DAGs!
```
:::
:::


::: {.callout-note}
## üí° Understanding DAFT

**DAFT (Directed Acyclic Factor Graphs Toolkit)** is a Python package for creating probabilistic graphical models. It's particularly useful for:

- Creating Directed Acyclic Graphs (DAGs)
- Visualizing causal relationships
- Communicating data generating processes
- Creating publication-quality figures

**Key DAFT Concepts:**

- **Nodes:** Represent variables or factors
- **Edges:** Show relationships between variables
- **Plates:** Indicate repeated structures
- **Styling:** Customize colors, shapes, and formatting
:::

## The Three DAGs: Your Mission

Your task is to recreate these three historical DAGs using DAFT, making them visually appealing and professionally formatted.
-->
<section id="dag-1-the-1747-understanding-correct-but-incomplete" class="level3">
<h3 class="anchored" data-anchor-id="dag-1-the-1747-understanding-correct-but-incomplete">DAG 1: The 1747 Understanding (Correct but Incomplete)</h3>
<p><strong>Historical Context:</strong> In 1747, James Lind discovered that lemons prevent scurvy through a controlled experiment. However, the understanding was incomplete - they knew lemons worked but not why.</p>
<p><strong>Your Task:</strong> Recreate this DAG showing the relationship between lemons and scurvy prevention. <!---
**Reference Image:**
![](https://raw.githubusercontent.com/flyaflya/persuasive/642288ea5f79050c05801c3d127084ac0f361a01/images/scurvy2.png)
--></p>
<div id="cell-dag-1-1747" class="cell" data-execution_count="2">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/dag-1-1747-output-1.png" id="dag-1-1747" width="530" height="153" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<section id="analysis-of-dag-1-the-1747-understanding" class="level4">
<h4 class="anchored" data-anchor-id="analysis-of-dag-1-the-1747-understanding">Analysis of DAG 1: The 1747 Understanding</h4>
<p>This DAG represents the historical understanding that emerged from James Lind‚Äôs 1747 experiment aboard the HMS Salisbury. Lind‚Äôs experiment was one of the first controlled clinical trials in medical history, where he divided sailors suffering from scurvy into groups and gave different treatments to each group.</p>
<p><strong>What the DAG shows:</strong> - <strong>Direct causal relationship:</strong> The model shows lemons directly preventing scurvy - <strong>Empirical evidence:</strong> This understanding was based on observational data and experimental evidence (lemons worked in practice) - <strong>Limitation:</strong> The mechanism was unknown - why lemons worked remained a mystery</p>
<p><strong>Why this understanding was incomplete:</strong> - Lind knew <strong>that</strong> lemons prevented scurvy, but not <strong>why</strong> - The critical intermediary (Vitamin C) was not yet discovered - This incomplete understanding would later cause the cure to be lost when lemons were replaced with alternatives that contained less of the essential nutrient</p>
<p><strong>Historical significance:</strong> This DAG represents a crucial moment where empirical observation led to a solution, even without mechanistic understanding. The yellow color of the ‚ÄúLemons‚Äù node emphasizes that this was a discovery about a specific food, while the thistle-colored ‚ÄúScurvy‚Äù node represents the disease being prevented.</p>
</section>
</section>
<section id="dag-2-the-misguided-belief-wrong-understanding" class="level3">
<h3 class="anchored" data-anchor-id="dag-2-the-misguided-belief-wrong-understanding">DAG 2: The Misguided Belief (Wrong Understanding)</h3>
<p><strong>Historical Context:</strong> Over time, people came to believe it was the acid in lemons that killed bacteria which was causing scurvy. This led to lemons being replaced by limes (cheaper but less Vitamin C) or just using acids like vinegar, causing scurvy to return.</p>
<p><strong>Your Task:</strong> Recreate this DAG showing the incorrect understanding of the data generating process. <!---
**Reference Image:**
![](https://raw.githubusercontent.com/flyaflya/persuasive/8aaffd0a3c967d0a26f506232f998130847be3e8/images/scurvy.png)
--></p>
<div id="cell-dag-2-misguided" class="cell" data-execution_count="3">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/dag-2-misguided-output-1.png" id="dag-2-misguided" width="785" height="389" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<section id="analysis-of-dag-2-the-misguided-belief" class="level4">
<h4 class="anchored" data-anchor-id="analysis-of-dag-2-the-misguided-belief">Analysis of DAG 2: The Misguided Belief</h4>
<p>This DAG represents the tragically incorrect understanding that emerged over time after Lind‚Äôs discovery. As the ‚Äúwhy‚Äù of scurvy prevention remained unknown, people developed a theoretical explanation that seemed logical at the time.</p>
<p><strong>What the DAG shows:</strong> - <strong>Two-step causal chain:</strong> Acid ‚Üí Bacteria Death ‚Üí Scurvy Prevention - <strong>Theoretical reasoning:</strong> The model proposes that acid kills bacteria in food, which then prevents scurvy - <strong>Confidence despite being wrong:</strong> The model appears complete and causal</p>
<p><strong>Why this understanding was wrong:</strong> - <strong>Bacteria don‚Äôt cause scurvy:</strong> Scurvy is a deficiency disease, not caused by bacteria - <strong>Acid is incidental:</strong> What mattered was not the acid (ascorbic acid), but rather that Vitamin C happened to be in acidic fruits - <strong>Confounded relationship:</strong> The correlation between acid and Vitamin C led to a fundamental misattribution of the causal mechanism</p>
<p><strong>Historical consequences:</strong> This erroneous understanding had devastating real-world impact: - <strong>Limes replaced lemons:</strong> Cheaper limes with less Vitamin C were adopted, thinking acid was the key ingredient - <strong>Vinegar used instead:</strong> Some ships tried using vinegar or other acids, completely ineffective against scurvy - <strong>Scurvy returned:</strong> Deaths from scurvy increased dramatically in the late 19th and early 20th centuries - <strong>Lost knowledge:</strong> The cure was effectively lost for over 150 years</p>
<p>The blue and orange colors in this DAG suggest the theoretical nature of this belief - a hypothesis that seemed plausible but was fundamentally incorrect. This DAG serves as a powerful reminder of how misattributed causality can lead to disaster when treating symptoms rather than understanding true mechanisms.</p>
</section>
</section>
<section id="dag-3-the-1928-understanding-complete-and-correct" class="level3">
<h3 class="anchored" data-anchor-id="dag-3-the-1928-understanding-complete-and-correct">DAG 3: The 1928 Understanding (Complete and Correct)</h3>
<p><strong>Historical Context:</strong> In 1928, the true mechanism was discovered - it was Vitamin C (ascorbic acid) that prevented scurvy. This complete understanding finally explained why lemons worked and why the acid theory was wrong.</p>
<p><strong>Your Task:</strong> Recreate this DAG showing the complete and correct understanding of the scurvy data generating process. <!---
**Reference Image:**
![](https://raw.githubusercontent.com/flyaflya/persuasive/main/images/scurvy3.png)
--></p>
<div id="cell-dag-3-1928" class="cell" data-execution_count="4">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/dag-3-1928-output-1.png" id="dag-3-1928" width="870" height="389" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<section id="analysis-of-dag-3-the-1928-understanding" class="level4">
<h4 class="anchored" data-anchor-id="analysis-of-dag-3-the-1928-understanding">Analysis of DAG 3: The 1928 Understanding</h4>
<p>This DAG represents the complete and correct understanding that emerged with the discovery of Vitamin C. This breakthrough finally explained both <strong>that</strong> and <strong>why</strong> lemons prevented scurvy, resolving over 180 years of confusion.</p>
<p><strong>What the DAG shows:</strong> - <strong>True causal mechanism:</strong> Vitamin C ‚Üí Collagen Synthesis ‚Üí Scurvy Prevention - <strong>Biochemical pathway:</strong> The DAG shows how Vitamin C affects the body‚Äôs ability to synthesize collagen - <strong>Complete understanding:</strong> This model explains both the prevention of scurvy and why deficiency causes symptoms</p>
<p><strong>Why this understanding is correct:</strong> - <strong>Biochemical evidence:</strong> Albert Szent-Gy√∂rgyi discovered Vitamin C in 1928, winning the Nobel Prize in 1937 - <strong>Mechanistic clarity:</strong> Vitamin C is a cofactor in collagen synthesis; without it, connective tissues deteriorate - <strong>Explains all prior observations:</strong> This model explains why lemons worked (Vitamin C), why acids seemed to work (they contained Vitamin C), and why the cure was lost (when switched to acids without Vitamin C)</p>
<p><strong>Historical significance:</strong> The discovery of Vitamin C represents one of the greatest triumphs in nutritional science: - <strong>Named for anti-scorbutic property:</strong> ‚ÄúAscorbic acid‚Äù means ‚Äúanti-scurvy acid‚Äù - <strong>Clarified confusion:</strong> Explained why citrus fruits worked and why acid alone didn‚Äôt - <strong>Preventable deaths:</strong> Millions of sailors and others died unnecessarily due to the 150-year gap in understanding - <strong>Lasting impact:</strong> This discovery led to vitamin fortification and nutritional science</p>
<p>The orange color of the ‚ÄúVitamin C‚Äù node represents the vitality and life-giving properties of this essential nutrient, while the green ‚ÄúCollagen Synthesis‚Äù node shows the biological process that maintains health. The purple ‚ÄúScurvy‚Äù node remains the same across all DAGs, showing the consistent outcome but with dramatically different understandings of causation.</p>
<p>This DAG serves as a model for understanding complex biological relationships - showing that empirical observation (DAG 1) and theoretical frameworks (DAG 2) must be validated through mechanistic understanding (DAG 3).</p>
</section>
</section>
<section id="comparative-analysis-the-evolution-of-understanding" class="level3">
<h3 class="anchored" data-anchor-id="comparative-analysis-the-evolution-of-understanding">Comparative Analysis: The Evolution of Understanding</h3>
<p>When comparing these three DAGs, we see the evolution of scientific understanding about scurvy prevention - from empirical observation through flawed theoretical reasoning to complete mechanistic understanding.</p>
<p><strong>From Observation to Understanding:</strong> - <strong>DAG 1 (1747):</strong> Represents the ‚Äúwhat works‚Äù stage - knowledge through empirical testing - <strong>DAG 2 (Misguided):</strong> Represents the ‚Äúwhy it might work‚Äù stage - flawed theoretical explanation - <strong>DAG 3 (1928):</strong> Represents the ‚Äúhow it actually works‚Äù stage - correct mechanistic understanding</p>
<p><strong>Key Differences in the DAGs:</strong></p>
<ol type="1">
<li><strong>Number of nodes:</strong>
<ul>
<li>DAG 1: 2 nodes (simplest, incomplete)</li>
<li>DAG 2: 3 nodes (expanded, but incorrect)</li>
<li>DAG 3: 3 nodes (complete and correct)</li>
</ul></li>
<li><strong>Causal pathways:</strong>
<ul>
<li>DAG 1: Direct causation (lemons ‚Üí scurvy prevention)</li>
<li>DAG 2: Indirect causation through wrong mechanism (acid ‚Üí bacteria death ‚Üí scurvy prevention)</li>
<li>DAG 3: Indirect causation through correct mechanism (Vitamin C ‚Üí collagen synthesis ‚Üí scurvy prevention)</li>
</ul></li>
<li><strong>Color coding meaning:</strong>
<ul>
<li>Each DAG uses color strategically to represent the nature of the understanding</li>
<li>Yellow/Green nodes represent food sources or beneficial nutrients</li>
<li>Blue/Orange nodes represent theoretical constructs</li>
<li>Purple nodes consistently represent the disease outcome</li>
</ul></li>
</ol>
<p><strong>Lessons for Data Science:</strong> The scurvy story teaches us critical lessons about causality, correlation, and the dangers of incomplete understanding:</p>
<ol type="1">
<li><strong>Empirical validity doesn‚Äôt guarantee comprehension</strong> (DAG 1)</li>
<li><strong>Intuitive theories can be dangerously wrong</strong> (DAG 2)</li>
<li><strong>Complete mechanistic understanding prevents tragic mistakes</strong> (DAG 3)</li>
<li><strong>Visualization through DAGs helps us think clearly about causality</strong> (all three DAGs)</li>
</ol>
<!--
## Student Requirements Section: Mastering DAFT Visualization {#student-analysis-section}

**Your Task:** Demonstrate your mastery of DAFT through comprehensive recreation of the three scurvy DAGs and thoughtful analysis. The bulk of your grade comes from successfully recreating the DAGs and answering the discussion questions.

::: {.callout-important}
## üìä Challenge Requirements

**Complete all DAG recreation sections:**

1. **DAG 1 (1747):** Lemons prevent scurvy - correct but incomplete
2. **DAG 2 (Misguided):** Acid kills bacteria - wrong understanding  
3. **DAG 3 (1928):** Vitamin C prevents scurvy - complete and correct
4. **Optional:** Add a little professional styling to the DAGs to make them more visually appealing (example: use nice fill colors and/or enclose the text in the ellipse completely).
:::

### Professional Quality Standards

**Your DAGs should:**

- (90% grade): Accurately recreate the reference images
- (100% grade): Add professional colors and possibly play with shapes to make it more visually appealing (example: use nice fill colors and/or enclose the text in the ellipse completely). Erase everything but the story of scurvy and the three DAGs
- Include clear, readable labels
- Demonstrate understanding of DAFT customization options
- Be suitable for a business or academic audience

### Example: Professional DAFT Node Styling

Here's an example (see @fig-example-node) of how to create a professionally styled node in DAFT with nice captions and references to the figure:

::: {#cell-fig-example-node .cell execution_count=5}
``` {.python .cell-code}
import daft
import matplotlib.pyplot as plt

# Create a PGM object
pgm = daft.PGM(dpi=150, alternate_style="outer")

# Example of a professionally styled node
pgm.add_node("vitamin_c", "Vitamin C\nIntake" + r" $(X)$", 1, 1, aspect = 3, scale = 1.1,
             plot_params={
                 'facecolor': 'lightgreen', 
                 'edgecolor': 'darkgreen', 
                 'linewidth': 2,
                 'alpha': 0.8,
             })
pgm.add_node("health", "Healthiness\n"+r" $(Y)$", 3.25, 1, aspect = 3, scale = 1.1,
             plot_params={
                 'facecolor': 'thistle', 
                 'edgecolor': 'purple', 
                 'linewidth': 2,
                 'alpha': 0.8,
             })
pgm.add_edge("vitamin_c", "health")

pgm.render()
```

::: {.cell-output .cell-output-display}
![Example: Professional DAFT Node Styling](index_files/figure-html/fig-example-node-output-1.png){#fig-example-node width=514 height=118}
:::
:::


**Key Styling Parameters:**

- `facecolor`: Background color of the node
- `edgecolor`: Border color of the node  
- `linewidth`: Thickness of the border
- `alpha`: Transparency (0.0 to 1.0)
- `fontsize`: Size of text inside the node
- `aspect`: Width/height aspect ratio of the node (default: 1.0)
- `scale`: Height of the node (default: 1.0)

## Getting Started: Repository Setup üöÄ

::: {.callout-important}
## üìÅ Getting Started

**Step 1:** Create a new repository in your GitHub account named "daftChallenge" (forked from [https://github.com/flyaflya/daftChallenge](https://github.com/flyaflya/daftChallenge))

**Step 2:** Clone your repository locally using Cursor (or VS Code)

**Step 3:** Be sure to install DAFT in your environment: `pip install 'daft-pgm'`.

**Step 4:** Modify your local copy of this `index.qmd` file  to complete the challenge and get it to be a github pages website.
:::

### Getting Started Tips

## Key DAFT Resources

**Essential DAFT Documentation:**

- [DAFT Documentation](https://docs.daft-pgm.org/en/latest/)
- [DAFT Examples](https://docs.daft-pgm.org/en/latest/examples/)
- [Matplotlib Colors](https://matplotlib.org/stable/gallery/color/named_colors.html)

**Key DAFT Parameters to Explore:**

- `plot_params`: Dictionary of matplotlib parameters for styling
- `aspect`: Controls node width (default: 1.0)
- `scale`: Controls node size (default: 1.0)
- `fontsize`: Text size in the node
- `alternate`: Use alternative node shape (True/False)

## Grading Rubric üéì

**90% Grade:** Successfully recreate all 3 DAGs with good visual quality.

**100% Grade:** Recreate all 3 DAGs with enhanced quality and visual aesthetics (example: use nice fill colors and/or enclose the text in the ellipse completely).

## Submission Checklist ‚úÖ

**Minimum Requirements (Required for Any Points):**

- [ ] Created repository named "daftChallenge" in your GitHub account (forked from [https://github.com/flyaflya/daftChallenge](https://github.com/flyaflya/daftChallenge))
- [ ] Cloned repository locally using Cursor (or VS Code)
- [ ] Installed DAFT package successfully
- [ ] Document rendered to HTML successfully
- [ ] HTML files uploaded to your repository
- [ ] GitHub Pages enabled and working
- [ ] Site accessible at `https://[your-username].github.io/daftChallenge/`

**90% Grade Requirements:**

- [ ] Successfully recreate all 3 DAGs
- [ ] Good visual quality with appropriate styling

**100% Grade Requirements:**

- [ ] All DAG recreations completed with professional quality
- [ ] Erase everything but the story of scurvy and the three DAGs (make it a nice concise narrative about scurvy)



-->
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "Óßã";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>